%Очистка памяти перед выполнением программы
clear;

%Ввод пользователем количеств оттенков красного, зеленого и синего цвета,
%которые будут участвовать в палитре
palitra=input('Введите количество оттенков красного, зеленого и синего цвета, участвующие в палитре: ');

%Создание пустых массивов

%images - массив эталонных изображений, переведенных в бинарную комбинацию.
%Первый индекс - номер изображения.
%Второй индекс - индекс бинарной комбинации, характеризующей данное изображение
%Значение массива - значение элемента данной бинарной комбинации, характеризующей данное изображение
images = zeros(50, 10000*palitra*3);

%notpreparedimages - массив палитровых изображений, готовых к отображению на экране в качестве ответа
%Первая координата - номер изображения
%Вторая и третья координаты - координаты пикселя данного изображения
%Значение массива - цвет данного пикселя данного изображения
notpreparedimages = zeros(50, 100, 100, 3);

%V -  массив, хранящий  изображение. Необходим для заполнения
%массива images
%Второй индекс V - номер элемента бинарной комбинации.
%Третий индекс V - цвет изображения
%Значение V - значение элемента бинарной комбинации
V = zeros(1, 10000, 3);
%V = double(V);

%Работа с каждым эталонным изображением
for i = 1 : 50
	%Получение набора из трех двумерных массивов, взятых из jpg-файла. Каждый массив отвечает за
	%интенсивность красного, зеленого и синего цвета каждого пикселя соответственно
	%После идет перевод изображения N*N к размеру 100*100 по методу ближайшего соседа
    MToDisplay=imresize(imread(['Разные\',int2str(i), '.jpg']), [100 100]);

    %Сохранение изображений в папку, чтобы убедиться, что все полноветные изображения приведены к палитровым
    %imwrite(MToDisplay, ['Палитровые\', int2str(i), '.jpg']);
		
    %Перевод значений массива из типа uint8 в тип double
    %MToDisplay=double(MToDisplay);
	
   
    %Перевод массива в вектор-строку
    for x = 1 : 3
        V(:,:,x)=reshape(MToDisplay(:, :, x), 1, 10000);
    end
	
    %Перевод вектора-строки в бинарную вектор-строку
    for j = 1:3
        for k=1:10000
            images(i,palitra*3*(k-1) + fix(V(1, k, j)/(256/palitra)) + palitra*(j-1) + 1) = true;
        end
    end

    %Сохранение изображения массива для вывода (если тестовое изображение будет распознано) 
    for j = 1:3
        for k=1:100
            for l=1:100
                notpreparedimages(i,k,l,j)=fix(MToDisplay(k, l, j)/(256/palitra))*fix(256/palitra);
            end
        end
    end
end

%palitra*3*(1-1) + fix(V(1, 1, 1)/fix(256/4)) + palitra*(1-1) + 1
%images(1,palitra*3*(1-1) + fix(V(1, 1, 1)/fix(256/4)) + palitra*(1-1) + 1)


% Перевод images к типу double
images=double(images);

% Описание эталонных портретов писателей 
answers{1}  = '1.  Барто';
answers{2}  = '2.  Блок';
answers{3}  = '3.   Брюсов';
answers{4}  = '4.   Бунин';
answers{5}  = '5.   Чехов';
answers{6}  = '6.   Чернышевский';
answers{7}  = '7.  Державин';
answers{8}  = '8.  Гоголь';
answers{9}  = '9.   Карамзин';
answers{10}  = '10.  Крылов';
answers{11}  = '11.  Лермонтов';
answers{12}  = '12.   Маршак';
answers{13}  = '13.   Маяковский';
answers{14}  = '14.   Некрасов';
answers{15}  = '15.   Пастернак';
answers{16}  = '16.  Пушкин';
answers{17}  = '17.  Цветаева';
answers{18}  = '18.   Тютчев';
answers{19}  = '19.   Ушинский';
answers{20}  = '20.   Некрасов';
answers{21}  = '21.   Пушкин';
answers{22}  = '22.   Куприн';
answers{23}  = '23.   Варламов';
answers{24}  = '24.   Островский';
answers{25}  = '25.   Ахматова';
answers{26}  = '26.   Маяковский';
answers{27}  = '27.   Блок';
answers{28}  = '28.   Державин';
answers{29}  = '29.   Лермонтов';
answers{30}  = '30.   Есенин';
answers{31}  = '31.   Цветаева';
answers{32}  = '32.   Суриков';
answers{33}  = '33.   Лермонтов';
answers{34}  = '34.   Крылов';
answers{35}  = '35.   Бунин';
answers{36}  = '36.   Тютчев';
answers{37}  = '37.   Ершов';
answers{38}  = '38.   Толстой';
answers{39}  = '39.  Маршак';
answers{40}  = '40.  Жуковский';
answers{41}  = '41.   Шекспир';
answers{42}  = '42.   Чуковский';
answers{43}  = '43.   Андерсен';
answers{44}  = '44.   Гюго';
answers{45}  = '45.  Гёте';
answers{46}  = '46.  Грибоедов';
answers{47}  = '47.   Дюма';
answers{48}  = '48.  Михалков';
answers{49}  = '49.  Чуковский';
answers{50}  = '50.   Есенин';  

%Эта часть кода отвечает за вычисление и вывод на экран графика
%степени схожести(количество совпадающих пикселей) каждого изображения с каждым.
transposedimages=images.';
mat=images*transposedimages;

[x,y]=meshgrid(1:1:50, 1:1:50);
surf(x,y,mat);


%Работа с тестовым изображением

%Получение набора из трех двумерных массивов, взятых из jpg-файла. Каждый массив отвечает за
%интенсивность красного, зеленого и синего цвета каждого пикселя соответственно
%После идет перевод изображения N*N к размеру 100*100 по методу ближайшего соседа
Buf=imresize(imread(['Разные\test', '.jpg']), [100 100]);

%Перевод массива в вектор-строку
for i = 1 : 3
    V(:,:,i)=reshape(Buf(:, :, i), 1, 10000);
end
	
%Перевод значений массива из типа int в тип double
Buf=double(Buf);

%Создание вектора-строки testimage, который будет хранить бинарную комбинацию тестового изображения
testimage = zeros(1, 10000*palitra*3);

%Заполнение вектора-столбца testimage
for j = 1:3
    for k=1:10000
        testimage(1, palitra*3*(k-1) + fix(V(1, k, j)/(256/palitra)) + palitra*(j-1) + 1)=true;
    end
end
testimage=double(testimage);



% Перемножаем эталонные и тестовую БК
% Результатом будет вектор-столбец, где каждое значение будет хранить
% количество пикселей тествого изображения, совпадающих с соответствующими 
% пикселями эталонных изображений
res = images * testimage';

% Ищем максимаьный элемент в полученном векторе,
% т. е. наиболее схожее эталонное изображение с
% тестовым
max = 0;
imax = 0;
for i = 1 : length(res)
    if res(i) > max
        max = res(i);
        imax = i;
    end;
end

%Назначаем порог схожести
threshold=20000;

if max > threshold
    %Выводим изображение на экран, если порог превышен
     result = zeros(100, 100, 3);
     result(:, :, :)=notpreparedimages(imax,:,:,:);
     result=uint8(result);
    %imshow(result);
    result = answers{imax};
else
    %Иначе выводим в консоли изображение не распознано
    result = 'не удалось распознать';
end

%Вывод результата
disp (['Ответ: ', result]);