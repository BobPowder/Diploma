%Очистка памяти перед выполнением программы
clear;
%Ввод пользователем количеств оттенков красного, зеленого и синего цвета,
%которые будут участвовать в палитре
palitra=input('Введите количество оттенков красного, зеленого и синего цвета, участвующие в палитре: ');

%Создание палитры оттенков, на основе которой полноцветные изображения будут переведены в палитровые
map=zeros(palitra^3, 3);
for k=1:palitra
    for j=1:palitra
        for i=1:palitra
            map((k-1)*palitra^2+(j-1)*palitra+i, 1)=double((i-1)/(palitra-1));
            map((k-1)*palitra^2+(j-1)*palitra+i, 2)=double((j-1)/(palitra-1));
            map((k-1)*palitra^2+(j-1)*palitra+i, 3)=double((k-1)/(palitra-1));
        end
    end
end


%Создание пустых массивов

%images - массив палитровых эталонных изображений, переведенных в бинарную комбинацию.
%Первая координата - номер изображения.
%Вторая координата - номер элемента бинарной комбинации, характеризующей данное изображение
%Значение массива - значение элемента данной бинарной комбинации, характеризующей данное изображение
images = zeros(10, 10000*(palitra^3));

%notpreparedimages - массив палитровых изображений, готовых к отображению на экране в качестве ответа
%Первая координата - номер изображения
%Вторая и третья координаты - координаты пикселя данного изображения
%Значение массива - цвет данного пикселя данного изображения
notpreparedimages = zeros(10, 100, 100);

%Buf -  массив, хранящий  изображение, перведенное из двумерного массива в вектор-строку. Необходим для заполнения
%массива images
%Также массив выполняет роль хранения палитрового тестового изображения, переведенного в бинарную комбинацию
%Индекс Buf - номер элемента бинарной комбинации.
%Значение Buf - значение элемента бинарной комбинации
Buf = zeros(1, 10000*(palitra^3));

%Работа с каждым эталонным изображением
for i = 1 : 10
	%Получение набора из трех двумерных массивов, взятых из jpg-файла. Каждый массив отвечает за
	%интенсивность красного, зеленого и синего цвета каждого пикселя соответственно
	%После идет перевод изображения N*N к размеру 100*100 по методу ближайшего соседа
	%Затем полноцветное изображение приводится к палитровому с палитрой, сделанной выше
    MToDisplay=rgb2ind(imresize(imread(['Разные Картины\', ...
        int2str(i), '.jpg']), [100 100]), map, 'nodither' );

    %Сохранение изображений в папку, чтобы убедиться, что все полноветные изображения приведены к палитровым
    imwrite(MToDisplay, map, ['Палитровые\', ...
        int2str(i), '.jpg']);
		
    %Перевод значений массива из типа int в тип double
    MToDisplay=double(MToDisplay);
	
    %Сохранение изображения массива для вывода (если тестовое изображение будет распознано) 
    notpreparedimages(i,:,:)=MToDisplay(:, :);
	
    %Перевод массива в вектор-строку
    Buf=reshape(MToDisplay, 1, 10000);
	
    %Перевод вектора-строки в бинарную вектор-строку
    for m=1:1:10000
        images(i, (m-1)*(palitra^3) + Buf(1, m) + 1)=true;
    end
end

% Перевод images к типу double
images=double(images);

% Описание эталонных картин 
answers{1}  = '1.  Ван Гог "Звездная ночь"';
answers{2}  = '2.  Васнецов "Богатыри"';
answers{3}  = '3.  Дали "Постоянство памяти"';
answers{4}  = '4.  Петров-Водкин "Купание красного коня"';
answers{5}  = '5.  Крамской "Неизвестная"';
answers{6}  = '6.  Репин "Иван Грозный и его сын"';
answers{7}  = '7.  Репин "Запорожцы пишут письмо турецкому султану"';
answers{8}  = '8.  Микеланджело "Сотворение Адама"';
answers{9}  = '9.  Карамзин';
answers{10}  = '10.  Крылов';

   

%Эта часть кода отвечает за вычисление и вывод на экран графика
%степени схожести(количество совпадающих пикселей) каждого изображения с каждым.
%transposedimages=images.'
%mat=images*transposedimages;

%[x,y]=meshgrid(1:1:10, 1:1:10);
%surf(x,y,mat);


%Работа с тестовым изображением
%Получение набора из трех двумерных массивов, взятых из jpg-файла. Каждый массив отвечает за
%интенсивность красного, зеленого и синего цвета каждого пикселя соответственно
%После идет перевод изображения N*N к размеру 100*100 по методу ближайшего соседа
%Затем полноцветное изображение приводится к палитровому с палитрой, сделанной выше 
Buf=reshape(rgb2ind(imresize(imread(['Разные Картины\test', ...
    '.jpg']), [100 100]), map, 'nodither' ), 10000, 1);
	
%Перевод значений массива из типа int в тип double
Buf=double(Buf);

%Создание вектора-столбца testimage, который будет хранить бинарную комбинацию тестового изображения
testimage = zeros(10000*(palitra^3), 1);

%Заполнение вектора-столбца testimage
for m=1:1:10000
    testimage((m-1)*(palitra^3) + Buf(m, 1) + 1, 1)=true;
end
testimage=double(testimage);


% Перемножаем эталонные и тестовую БК
% Результатом будет вектор-столбец, где каждое значение будет хранить
% количество пикселей тествого изображения, совпадающих с соответствующими 
% пикселями эталонных изображений
res = images * testimage;

% Ищем максимаьный элемент в полученном векторе,
% т. е. наиболее схожее эталонное изображение с
% тестовым
max = 0;
imax = 0;
for i = 1 : length(res)
    if res(i) > max
        max = res(i);
        imax = i;
    end;
end

%Назначаем порог схожести
threshold=9800;

if max > threshold
    %Выводим изображение на экран, если порог превышен
     result = zeros(100, 100);
     for i=1:1:100
         result(i, :)=notpreparedimages(imax,i,:)
     end
    imshow(result, map);
    result = answers{imax};
else
    %Иначе выводим в консоли изображение не распознано
    result = 'не удалось распознать';
end

%Вывод результата
disp (['Ответ: ', result]);